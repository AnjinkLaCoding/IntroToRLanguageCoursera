| Missing values play an important role in statistics and data analysis. Often, missing values must not be ignored, but rather
| they should be carefully studied to see if there's an underlying pattern or cause for their missingness.

...

  |======                                                                                                                 |   5%
| In R, NA is used to represent any value that is 'not available' or 'missing' (in the statistical sense). In this lesson, we'll
| explore missing values further.

...

  |============                                                                                                           |  10%
| Any operation involving NA generally yields NA as the result. To illustrate, let's create a vector c(44, NA, 5, NA) and assign
| it to a variable x.

> x <- c(44, NA, 5, NA)

| Great job!

  |==================                                                                                                     |  15%
| Now, let's multiply x by 3.

> x*3
[1] 132  NA  15  NA

| Keep up the great work!

  |========================                                                                                               |  20%
| Notice that the elements of the resulting vector that correspond with the NA values in x are also NA.

...

  |==============================                                                                                         |  25%
| To make things a little more interesting, lets create a vector containing 1000 draws from a standard normal distribution with
| y <- rnorm(1000).

> y <- rnorm(1000)

| You are amazing!

  |====================================                                                                                   |  30%
| Next, let's create a vector containing 1000 NAs with z <- rep(NA, 1000).

> z <- rep(NA, 1000)

| You are quite good my friend!

  |==========================================                                                                             |  35%
| Finally, let's select 100 elements at random from these 2000 values (combining y and z) such that we don't know how many NAs
| we'll wind up with or what positions they'll occupy in our final vector -- my_data <- sample(c(y, z), 100).

> my_data <- sample(c(y, z), 100)

| You got it!

  |================================================                                                                       |  40%
| Let's first ask the question of where our NAs are located in our data. The is.na() function tells us whether each element of a
| vector is NA. Call is.na() on my_data and assign the result to my_na.

> my_na <- is.na(my_data)

| Great job!

  |======================================================                                                                 |  45%
| Now, print my_na to see what you came up with.

> MY_NA
Error: object 'MY_NA' not found
> my_na
  [1] FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
 [21]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE
 [41]  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE
 [61] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
 [81]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE

| Excellent job!

  |============================================================                                                           |  50%
| Everywhere you see a TRUE, you know the corresponding element of my_data is NA. Likewise, everywhere you see a FALSE, you know
| the corresponding element of my_data is one of our random draws from the standard normal distribution.

...

  |=================================================================                                                      |  55%
| In our previous discussion of logical operators, we introduced the `==` operator as a method of testing for equality between
| two objects. So, you might think the expression my_data == NA yields the same results as is.na(). Give it a try.

> my_data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [42] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [83] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| Your dedication is inspiring!

  |=======================================================================                                                |  60%
| The reason you got a vector of all NAs is that NA is not really a value, but just a placeholder for a quantity that is not
| available. Therefore the logical expression is incomplete and R has no choice but to return a vector of the same length as
| my_data that contains all NAs.

...

  |=============================================================================                                          |  65%
| Don't worry if that's a little confusing. The key takeaway is to be cautious when using logical expressions anytime NAs might
| creep in, since a single NA value can derail the entire thing.

...

  |===================================================================================                                    |  70%
| So, back to the task at hand. Now that we have a vector, my_na, that has a TRUE for every NA and FALSE for every numeric
| value, we can compute the total number of NAs in our data.

...

  |=========================================================================================                              |  75%
| The trick is to recognize that underneath the surface, R represents TRUE as the number 1 and FALSE as the number 0. Therefore,
| if we take the sum of a bunch of TRUEs and FALSEs, we get the total number of TRUEs.

...

  |===============================================================================================                        |  80%
| Let's give that a try here. Call the sum() function on my_na to count the total number of TRUEs in my_na, and thus the total
| number of NAs in my_data. Don't assign the result to a new variable.

> sum(my_na)
[1] 53

| You nailed it! Good job!

  |=====================================================================================================                  |  85%
| Pretty cool, huh? Finally, let's take a look at the data to convince ourselves that everything 'adds up'. Print my_data to the
| console.

> my_data
  [1] -0.17071835  0.51336983          NA          NA  2.56063876          NA          NA          NA -0.28286113          NA
 [11]          NA  0.37674493          NA          NA          NA  0.22071295  0.13099010 -0.94229751  1.10209472  3.86885429
 [21]          NA          NA          NA -1.76904218          NA  1.50352962          NA          NA          NA  1.46554598
 [31]  0.98059695          NA -0.14262147  0.98944139 -0.05289617 -1.49698739  0.51866492          NA          NA          NA
 [41]          NA          NA  0.38857484          NA          NA  0.76629120 -0.34099652          NA  0.33772311          NA
 [51] -0.66379925          NA          NA          NA          NA -0.66966372  0.32082964          NA          NA -1.02730581
 [61] -0.05798242  0.99605069          NA          NA          NA -1.70293167          NA          NA  0.68682149          NA
 [71]  0.60028526          NA -0.84175305  0.20253240 -0.32578957          NA  0.53346499 -0.26260154 -0.49840869          NA
 [81]          NA          NA  0.16920794          NA -1.04260768 -1.06382335  0.58881066          NA -0.29355109 -1.06448553
 [91]          NA          NA          NA -0.45215574          NA          NA          NA          NA  0.22582402  1.03487415

| Excellent job!

  |===========================================================================================================            |  90%
| Now that we've got NAs down pat, let's look at a second type of missing value -- NaN, which stands for 'not a number'. To
| generate NaN, try dividing (using a forward slash) 0 by 0 now.

> 0/0
[1] NaN

| You are doing so well!

  |=================================================================================================================      |  95%
| Let's do one more, just for fun. In R, Inf stands for infinity. What happens if you subtract Inf from Inf?

> Inf - Inf
[1] NaN
